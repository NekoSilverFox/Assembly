; 88 - 转移的目的地址在寄存器中的CALL指令
; =================================================================
; call 16位 reg
;
; CPU执行 “call 16位 reg”时相当于进行
; 	push ip
; 	call 16位 reg
; ===============================================================

; 以下程序执行后，AX中的值为多少
; =================================================================;
assume cs:codesg
; =================================================================
codesg segment
start:		mov ax, 6
		call ax		; sp 在默认情况下 == 0000
		inc ax		; 所以，一旦call就会导致栈顶越界，0000 - 2 == FFFE
		mov bp, sp	
		add ax, [bp]	; FFFE处又存放了call指令下一条的偏移地址 5，==> ax = ax + 5 = 6 + 5 == 11D == AH

		mov ax, 4c00h
		int 21h
codesg ends
; =================================================================
end start

